import { Block } from 'bitcore-lib';
import BitcoinBlockModel from './models/BitcoinBlockModel';
import BitcoinLockTransactionModel from './models/BitcoinLockTransactionModel';
import BitcoinSidetreeTransactionModel from './models/BitcoinSidetreeTransactionModel';
import BitcoinTransactionModel from './models/BitcoinTransactionModel';
import IBitcoinWallet from './interfaces/IBitcoinWallet';
import { IBlockInfo } from './BitcoinProcessor';
export default class BitcoinClient {
    private bitcoinPeerUri;
    readonly requestTimeout: number;
    readonly requestMaxRetries: number;
    private sidetreeTransactionFeeMarkupPercentage;
    private estimatedFeeSatoshiPerKB?;
    private readonly bitcoinAuthorization?;
    private readonly bitcoinWallet;
    private walletNameToUse;
    constructor(bitcoinPeerUri: string, bitcoinRpcUsername: string | undefined, bitcoinRpcPassword: string | undefined, bitcoinWalletOrImportString: IBitcoinWallet | string, requestTimeout: number, requestMaxRetries: number, sidetreeTransactionFeeMarkupPercentage: number, estimatedFeeSatoshiPerKB?: number | undefined);
    initialize(): Promise<void>;
    private waitUntilBitcoinCoreIsReady;
    private initializeBitcoinCore;
    static generatePrivateKey(network: 'mainnet' | 'livenet' | 'testnet' | undefined): string;
    static convertBtcToSatoshis(amountInBtc: number): number;
    broadcastSidetreeTransaction(bitcoinSidetreeTransaction: BitcoinSidetreeTransactionModel): Promise<string>;
    broadcastLockTransaction(bitcoinLockTransaction: BitcoinLockTransactionModel): Promise<string>;
    createSidetreeTransaction(transactionData: string, minimumFeeInSatoshis: number): Promise<BitcoinSidetreeTransactionModel>;
    createLockTransaction(lockAmountInSatoshis: number, lockDurationInBlocks: number): Promise<BitcoinLockTransactionModel>;
    createRelockTransaction(existingLockTransactionId: string, existingLockDurationInBlocks: number, newLockDurationInBlocks: number): Promise<BitcoinLockTransactionModel>;
    createReleaseLockTransaction(existingLockTransactionId: string, existingLockDurationInBlocks: number): Promise<BitcoinLockTransactionModel>;
    private createWallet;
    private loadWallet;
    getBlock(hash: string): Promise<BitcoinBlockModel>;
    getBlockHash(height: number): Promise<string>;
    getBlockInfoFromHeight(height: number): Promise<IBlockInfo>;
    getBlockInfo(hash: string): Promise<IBlockInfo>;
    getCurrentBlockHeight(): Promise<number>;
    getBalanceInSatoshis(): Promise<number>;
    getTransactionFeeInSatoshis(transactionId: string): Promise<number>;
    private addWatchOnlyAddressToWallet;
    private broadcastTransactionRpc;
    private isAddressAddedToWallet;
    private getCurrentEstimatedFeeInSatoshisPerKB;
    private updateEstimatedFeeInSatoshisPerKB;
    private getTransactionOutValueInSatoshi;
    getRawTransaction(transactionId: string): Promise<BitcoinTransactionModel>;
    static convertToBitcoinTransactionModels(block: Block): BitcoinTransactionModel[];
    private getRawTransactionRpc;
    private static createTransactionFromBuffer;
    private static createBitcoreTransactionWrapper;
    private createTransaction;
    private calculateTransactionFee;
    private createFreezeTransaction;
    private createSpendToFreezeTransaction;
    private createSpendToWalletTransaction;
    private createSpendTransactionFromFrozenTransaction;
    private createUnspentOutputFromFrozenTransaction;
    private static createFreezeScript;
    private static serializeSignedTransaction;
    private static createBitcoinInputModel;
    private static createBitcoinOutputModel;
    private static createBitcoinTransactionModel;
    private getUnspentOutputs;
    private rpcCall;
    private fetchWithRetry;
}
